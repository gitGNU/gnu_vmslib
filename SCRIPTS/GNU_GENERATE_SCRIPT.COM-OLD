$! GNU_GENERATE_SCRIPT.COM -- General startup script.
$! Copyright (C) 1994 the Free Software Foundation, Inc.
$!
$! Author: Richard Levitte <levitte@e.kth.se>
$!
$! This file is a part of GNU VMSLIB, the GNU library for porting GNU
$! software to VMS.
$!
$! GNU VMSLIB is free software; you can redistribute it and/or
$! modify it under the terms of the GNU General Public License
$! as published by the Free Software Foundation; either version 2
$! of the License, or (at your option) any later version.
$! 
$! GNU VMSLIB is distributed in the hope that it will be useful,
$! but WITHOUT ANY WARRANTY; without even the implied warranty of
$! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
$! GNU General Public License for more details.
$! 
$! You should have received a copy of the GNU General Public License
$! along with GNU VMSLIB; if not, write to the Free Software
$! Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
$
$! GNU_STARTUP.COM reads the data from the file GNU_STARTUP.DAT in the
$! same directory.
$!
$! Description:
$!
$! This command file will just read a file, given through the argument P1,
$! and generate a command file from it.  The name of the command file is
$! given in P2.
$!
$! A description of the format of the input is given at the end of this file.
$!
$! The generated file will have a specific format, to make it possible to
$! tuck in into a larger command file.
$!
$ open/read/error=noinfile gnu_data_file 'p1'
$ open/write/error=nooutfile gnu_startup_file 'p2'
$ on control_y then goto bugout
$ on error then goto bugout
$ write/error=bugout gnu_startup_file "$ __debug_save_verify = 'f$verify(0)'"
$ write/error=bugout gnu_startup_file "$! Generated from ",p1
$!
$
$ started := no
$ keep := yes
$ comment_i = 0
$ comment0 = ""
$loop_file:
$ line_i = 0
$ line0 = ""
$loop_file2:
$ line'line_i' = ""
$ read/end=nomore/error=nomore gnu_data_file line'line_i'
$ if f$extract(0,1,line'line_i') .eqs. "!"
$  then
$   if started
$    then
$     write/error=bugout gnu_startup_file "'do'$",line'line_i'
$    else
$     comment'comment_i' = "'do'$" + line'line_i'
$     comment_i = comment_i + 1
$    endif
$   goto loop_file2
$  endif
$ if f$extract(f$length(line'line_i')-1, 1, line'line_i') .eqs. "-"
$  then
$   line_i = line_i + 1
$   goto loop_file2
$  endif
$ if line_i .eq. 0 .and. line0 .eqs. "" then goto loop_file
$resume_loop_file:
$ if f$extract(0,1,line0) .nes. " "
$  then
$   if started then goto several_p ! Shouldn't be necessary!
$   started := yes
$   title = ""
$   e = f$element(0," ",line0)
$   utility = f$element(0,"-",e)
$   version = f$element(1,"-",e)
$   if f$length(line0) .gt. f$length(e) then -
	title=f$edit(f$extract(f$length(e)+1,f$length(line0),line0),"TRIM")
$   if title .eqs. "" then title = e
$   write sys$error "%GNU_GENERATE_SCRIPT-I-GENTITLE, Generating ",p2," for ",title
$
$   write/error=bugout gnu_startup_file "$! This is the startup file for ",title
$   type sys$input /out=gnu_startup_file
$DECK
$!
$! Description:
$!
$! P1 = comma-separated flags.
$!
$! The flags can be any of these.  If one flag appears several times,
$! the last occurense gets precedense over the others:
$!	TABLE=/SYSTEM		logicals are defined in the system table
$!	TABLE=/GROUP		logicals are defined in the group table
$!	TABLE=/JOB		logicals are defined in the job table
$!	TABLE=/PROCESS		logicals are defined in the process table
$!				(this is the default)
$!      INSTALL_IMAGE		install the image
$!	NOINSTALL_IMAGE 	do NOT install the image (default)
$!	LOGICALS		define the needed logicals if not yet defined
$!				(default)
$!	NOLOGICALS		do NOT define any logical
$!      FORCELOGICALS		define the needed logicals even if already
$!				defined!
$!      NOTON=(node[,...])	do not do this on the node "node"
$!
$!	VERBOSE			Tell the user what you're doing (default)
$!      NOVERBOSE		Be quiet!
$!	QUIET			alias for NOVERBOSE
$!
$!	DEBUG			Write the statements on the screen, and
$!				do NOT execute them.
$!      NODEBUG			Do not debug.
$!	VERIFY			As DEBUG, but DO execute the statements.
$!	NOVERIFY
$!
$ ON CONTROL_Y THEN GOTO bugout
$ ON ERROR THEN GOTO bugout
$ tmp_status = 1
$ proc = F$ENVIRONMENT("PROCEDURE")
$ startupdir = F$PARSE(proc,,,"NODE")+f$parse(proc,,,"DEVICE")+-
	f$parse(proc,,,"DIRECTORY")
$ node = F$EDIT(F$GETSYI("NODENAME"),"TRIM")
$ keywords = "/TABLE=/NOTON=/INSTALL_IMAGE/LOGICALS/FORCELOGICALS/NOINSTALL_IMAGE/NOLOGICALS/VERBOSE/QUIET/NOVERBOSE/DEBUG/NODEBUG/VERIFY/NOVERIFY/"
$ gnu_debug := NO
$ gnu_verify := NO
$ gnu_table = ""
$ gnu_table_switch = ""
$ gnu_install_image := NO
$ gnu_logicals := YES
$ gnu_exclusions = ","
$ gnu_antinodes = ","
$ gnu_verbose := YES
$ gnu_forcelogicals := NO
$ flags = p1
$loop_flags:
$ IF flags .NES. ""
$  THEN
$   endp = F$LOCATE(",",flags)
$   IF endp .NE. F$LENGTH(flags)
$    THEN
$     p = F$LOCATE("(",flags)
$     IF p .LT. endp
$      THEN
$	p = p + F$LOCATE(")",F$EXTRACT(p, F$LENGTH(flags), flags))
$	IF p .GT. endp THEN
		endp = p + F$LOCATE(",",F$EXTRACT(p, F$LENGTH(flags), flags))
$      ENDIF
$    ENDIF
$   e = F$EXTRACT(0,endp,flags)
$   IF F$EXTRACT(endp,1,flags) .EQS. "," THEN endp = endp + 1
$   flags = F$EXTRACT(endp, F$LENGTH(flags), flags)
$   keyword = F$EXTRACT(0,F$LOCATE("=",e),e)
$   lable = keyword
$   IF keyword .nes. e THEN keyword = keyword + "="
$   value = F$EXTRACT(F$LENGTH(keyword),F$LENGTH(e),e)
$   IF F$EXTRACT(0,1,value) .EQS. "(" -
	.AND. F$EXTRACT(F$LENGTH(value)-1,1,value) .EQS. ")" THEN -
	value = F$EXTRACT(1,F$LENGTH(value)-2,value)
$   IF keywords - ("/"+keyword+"/") .NES. keywords THEN GOTO F_'lable'
$  F_TABLE:
$   gnu_table_switch := 'value'
$   IF gnu_table_switch .EQS. "/SYSTEM" THEN gnu_table = "LNM$SYSTEM"
$   IF gnu_table_switch .EQS. "/GROUP" THEN gnu_table = "LNM$GROUP"
$   IF gnu_table_switch .EQS. "/JOB" THEN gnu_table = "LNM$JOB"
$   IF gnu_table_switch .EQS. "/PROCESS" .OR. gnu_table_switch .EQS. "" THEN -
	gnu_table = "LNM$PROCESS"
$   GOTO loop_flags
$  F_NOTON:
$   gnu_antinodes = "," + value + ","
$   IF gnu_antinodes - (","+node+",") .NES. gnu_antinodes THEN GOTO exit
$   GOTO loop_flags
$  F_EXCLUDE:
$   gnu_exclusions = gnu_exclusions + F$EDIT(value,"UPCASE") + ","
$   GOTO loop_flags
$  F_QUIET:
$   keyword := NOVERBOSE
$  F_NOVERBOSE:
$  F_NODEBUG:
$  F_NOVERIFY:
$  F_NOLOGICALS:
$  F_NOINSTALL_IMAGE:
$   gnu_'F$EXTRACT(2,F$LENGTH(keyword)-2,keyword)' := NO
$   GOTO loop_flags
$  F_DEBUG:
$   gnu_verify := NO
$   GOTO F_VERBOSE
$  F_VERIFY:
$   gnu_debug := NO
$  F_VERBOSE:
$  F_LOGICALS:
$  F_INSTALL_IMAGE:
$  F_FORCELOGICALS:
$   gnu_'keyword' := YES
$   GOTO loop_flags
$  ENDIF
$
$EOD
$   hacked_utility = utility
$   if version .nes. "-"
$    then
$     hacked_utility = hacked_utility
$     version_i = 0
$     c = "$"
$    loop_utility:
$     e = f$element(version_i,".",version)
$     version_i = version_i + 1
$     if e .nes. "."
$      then
$       hacked_utility = hacked_utility + c + e
$       c = "_"
$       goto loop_utility
$      endif
$    endif
$   write/error=bugout gnu_startup_file -
	"$!GNU NODE: GNU_",hacked_utility,":",line0
$
$   open/read gnu_temp_data 'p1'
$   gnu_extra_file := gnu_temp_data
$  loop_data_file:
$   read/end=loop_data_file_end/err=loop_data_file_end gnu_temp_data temp_line
$   write/error=bugout gnu_startup_file "$!GNU DATA: ",temp_line
$   goto loop_data_file
$  loop_data_file_end:
$   close gnu_temp_data
$   gnu_extra_file :=
$
$   write/error=bugout gnu_startup_file "$GNU_",hacked_utility,":"
$   type sys$input /out=gnu_startup_file
$DECK
$ gnu_verify_stmt = " !"
$ gnu_noverify_stmt = " !"
$ IF gnu_verify
$  THEN
$   gnu_verify_stmt = "__save_verify = F$VERIFY(1) !"
$   gnu_noverify_stmt = "__save_noverify = 'F$VERIFY(__save_verify)' !"
$  ENDIF
$ do :=
$ IF gnu_debug THEN do := "$!"
$ IF gnu_debug THEN WRITE SYS$ERROR "%GNU_GENERATE_SCRIPT-I-COMMENTEDLINES,  all lines are commented with a ""$!"""
$ IF gnu_debug THEN SET VERIFY
$EOD
$!  write/error=bugout gnu_startup_file "$ if gnu_debug then goto GNU_DEBUG_",hacked_utility
$  else
$   if started
$    then
$     goto A_'f$edit(f$element(0,"\",line0),"collapse")'
$    A_D:
$     name = f$element(1,"\",line0)
$     write/error=bugout gnu_startup_file "'do'$ IF .NOT. gnu_forcelogicals .AND. -"
$     write/error=bugout gnu_startup_file "'do'     F$TRNLNM(""",f$element(1,"\",line0),""",gnu_table) .NES. """" THEN -
$     write/error=bugout gnu_startup_file "'do'        GOTO SKIP_",name
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_verify_stmt'"
$     write/error=bugout gnu_startup_file "'do'$ DEFINE 'gnu_table' ",name,-
f$element(2,"\",line0)," -"
$     i = 0
$    sub_A_D:
$     i = i + 1
$     if i .le. line_i
$      then
$	write/error=bugout gnu_startup_file "'do' ",line'i'
$	goto sub_A_D
$      endif
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_noverify_stmt'"
$     write/error=bugout gnu_startup_file "$SKIP_",name,":"
$     goto loop_file
$    A_SL:
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_verify_stmt'"
$     write/error=bugout gnu_startup_file "'do'$ ",f$element(1,"\",line0)," := ",f$element(2,"\",line0)
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_noverify_stmt'"
$     goto loop_file
$    A_SG:
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_verify_stmt'"
$     write/error=bugout gnu_startup_file "'do'$ ",f$element(1,"\",line0)," :== ",f$element(2,"\",line0)
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_noverify_stmt'"
$     goto loop_file
$    A_H:
$     write/error=bugout gnu_startup_file "'do'$ IF gnu_forcelogicals .and. gnu_logicals THEN GOTO DONT_MAKE_HELP"
$     value = f$element(1,"\",line0)
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_verify_stmt'"
$     write/error=bugout gnu_startup_file "'do'$ hlp_i = 0"
$     write/error=bugout gnu_startup_file "'do'$ hlp_value := ",value
$     write/error=bugout gnu_startup_file "$HLPLOOP:"
$     write/error=bugout gnu_startup_file "'do'$ name = ""HLP$LIBRARY"""
$     write/error=bugout gnu_startup_file "'do'$ IF hlp_i .NE. 0 THEN name = name + ""_'","'hlp_i'"""
$     write/error=bugout gnu_startup_file "'do'$ hlp_i = hlp_i + 1"
$     write/error=bugout gnu_startup_file "'do'$ IF f$trnlnm(name,gnu_table) .EQS. hlp_value THEN GOTO no_hlp"
$     write/error=bugout gnu_startup_file "'do'$ IF f$trnlnm(name,gnu_table) .NES. """" THEN GOTO hlploop"
$     write/error=bugout gnu_startup_file "'do'$ DEFINE 'gnu_table' 'name' 'hlp_value'"
$     write/error=bugout gnu_startup_file "$NO_HLP:"
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_noverify_stmt'"
$     write/error=bugout gnu_startup_file "$DONT_MAKE_HELP:"
$     goto loop_file
$    A_I:
$     write/error=bugout gnu_startup_file "'do'$ IF .NOT. gnu_install_image THEN GOTO DONT_INSTALL_IMAGE"
$     write/error=bugout gnu_startup_file "'do'$ 'gnu_verify_stmt'"
$     write/error=bugout gnu_startup_file "'do'$ needed_privs = ""CMKRNL,SYSGBL,PRMGBL"""
$     write/error=bugout gnu_startup_file "'do'$ command = ""ADD"""
$     write/error=bugout gnu_startup_file "'do'$ IF f$file_attrib(bindir+""emacs.exe"",""KNOWN"") THEN command = ""REPLACE"""
$     write/error=bugout gnu_startup_file "'do'$ curpriv = f$getjpi("""",""CURPRIV"")"
$     write/error=bugout gnu_startup_file "'do'$ SET PROCESS/PRIV=('needed_privs)"
$     write/error=bugout gnu_startup_file "'do'$ IF f$privilege(needed_privs) THEN GOTO HAVE_PRIVS"
$     write/error=bugout gnu_startup_file "'do'$ WRITE SYS$ERROR ""You need the privileges "",needed_privs,-"
$     write/error=bugout gnu_startup_file "'do'	"" to install Emacs ",f$element(2,"\",line0),""""
$     write/error=bugout gnu_startup_file "'do'$ GOTO END_INSTALL_IMAGE"
$     write/error=bugout gnu_startup_file "$HAVE_PRIVS:"
$     write/error=bugout gnu_startup_file "'do'$ install := $INSTALL/COMMAND_MODE"
$     write/error=bugout gnu_startup_file "'do'$ install 'command' ",-
	f$element(1,"\",line0)," ",f$element(2,"\",line0)
$     write/error=bugout gnu_startup_file "$END_INSTALL_IMAGE:"
$     write/error=bugout gnu_startup_file "'do'$ SET PROCESS/PRIV=(noall,'curpriv')"
$     write/error=bugout gnu_startup_file "$ 'gnu_noverify_stmt'"
$     write/error=bugout gnu_startup_file "$DONT_INSTALL_IMAGE:"
$     goto loop_file
$    endif
$  endif
$ goto loop_file
$bugout:
$ tmp_status=$status
$ if "''gnu_extra_file'" .nes. ""
$  then
$   close 'gnu_extra_file
$  endif
$ line0 = ""
$ keep := no
$nomore:
$ if line_i .ne. 0 .or. line0 .nes. "" then goto resume_loop_file
$ if keep then write/error=bugout gnu_startup_file "$bugout:"
$ if keep then write/error=bugout gnu_startup_file "a = 'f$verify(__debug_save_verify)'"
$ if keep then write/error=bugout gnu_startup_file "$!GNU NODE END"
$ if keep then write/error=bugout gnu_startup_file "$exit: EXIT"
$ close gnu_startup_file
$ if .not. keep then delete 'f$parse(p2,"*.*;*")'
$nooutfile:
$ close gnu_data_file
$nofile:
$exit:
$ exit
